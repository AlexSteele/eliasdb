/* 
 * EliasDB
 *
 * Copyright 2016 Matthias Ladkau. All rights reserved.
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. 
 */

/*
Parser which produces a parse tree from a given set of lexer tokens.

Based on an article by Douglas Crockford:

Top Down Operator Precedence
http://javascript.crockford.com/tdop/tdop.html
*/
package parser

import (
	"bytes"
	"fmt"

	"devt.de/common/stringutil"
)

// AST Nodes
// =========

/*
ASTNode models a node in the AST
*/
type ASTNode struct {
	Name     string     // Name of the node
	Token    *LexToken  // Lexer token of this ASTNode
	Children []*ASTNode // Child nodes
	Runtime  Runtime    // Runtime component for this ASTNode

	binding        int                                                             // Binding power of this node
	nullDenotation func(p *parser, self *ASTNode) (*ASTNode, error)                // Configure token as beginning node
	leftDenotation func(p *parser, self *ASTNode, left *ASTNode) (*ASTNode, error) // Configure token as left node
}

/*
Create a new instance of this ASTNode which is connected to a concrete lexer token.
*/
func (n *ASTNode) instance(p *parser, t *LexToken) *ASTNode {
	ret := &ASTNode{n.Name, t, make([]*ASTNode, 0, 2), nil, n.binding, n.nullDenotation, n.leftDenotation}
	if p.rp != nil {
		ret.Runtime = p.rp.Runtime(ret)
	}
	return ret
}

/*
String returns a string representation of this token.
*/
func (n *ASTNode) String() string {
	var buf bytes.Buffer
	n.levelString(0, &buf)
	return buf.String()
}

/*
levelString function to recursively print the tree.
*/
func (n *ASTNode) levelString(indent int, buf *bytes.Buffer) {

	// Print current level

	buf.WriteString(stringutil.GenerateRollingString(" ", indent*2))

	if n.Token.Id == T_VALUE || n.Token.Id == T_NODEKIND {
		buf.WriteString(fmt.Sprintf(n.Name+": %v", n.Token))
	} else {
		buf.WriteString(n.Name)
	}

	buf.WriteString("\n")

	// Print children

	for _, child := range n.Children {
		child.levelString(indent+1, buf)
	}
}

/*
Map of ast nodes corresponding to lexer tokens
*/
var astNodeMap map[LexTokenId]*ASTNode

/*
Extra tokens generated by the parser.
*/
const T_SHOWTERM = LexTokenId(-1)

func init() {
	astNodeMap = map[LexTokenId]*ASTNode{
		T_EOF:           &ASTNode{N_EOF, nil, nil, nil, 0, nd_Term, nil},
		T_VALUE:         &ASTNode{N_VALUE, nil, nil, nil, 0, nd_Term, nil},
		T_NODEKIND:      &ASTNode{N_VALUE, nil, nil, nil, 0, nd_Term, nil},
		T_TRUE:          &ASTNode{N_TRUE, nil, nil, nil, 0, nd_Term, nil},
		T_FALSE:         &ASTNode{N_FALSE, nil, nil, nil, 0, nd_Term, nil},
		T_NULL:          &ASTNode{N_NULL, nil, nil, nil, 0, nd_Term, nil},
		T_AT:            &ASTNode{N_FUNC, nil, nil, nil, 0, nd_Func, nil},
		T_ORDERING:      &ASTNode{N_ORDERING, nil, nil, nil, 0, nd_WithFunc, nil},
		T_FILTERING:     &ASTNode{N_FILTERING, nil, nil, nil, 0, nd_WithFunc, nil},
		T_NULLTRAVERSAL: &ASTNode{N_NULLTRAVERSAL, nil, nil, nil, 0, nd_WithFunc, nil},

		// Special tokens - always handled in a denotation function

		T_COMMA:  &ASTNode{N_COMMA, nil, nil, nil, 0, nil, nil},
		T_GROUP:  &ASTNode{N_GROUP, nil, nil, nil, 0, nil, nil},
		T_END:    &ASTNode{N_END, nil, nil, nil, 0, nil, nil},
		T_AS:     &ASTNode{N_AS, nil, nil, nil, 0, nil, nil},
		T_FORMAT: &ASTNode{N_FORMAT, nil, nil, nil, 0, nil, nil},

		// Keywords

		T_GET:    &ASTNode{N_GET, nil, nil, nil, 0, nd_Get, nil},
		T_LOOKUP: &ASTNode{N_LOOKUP, nil, nil, nil, 0, nd_Lookup, nil},
		T_FROM:   &ASTNode{N_FROM, nil, nil, nil, 0, nd_From, nil},
		T_WHERE:  &ASTNode{N_WHERE, nil, nil, nil, 0, nd_Prefix, nil},

		T_UNIQUE:      &ASTNode{N_UNIQUE, nil, nil, nil, 0, nd_Prefix, nil},
		T_UNIQUECOUNT: &ASTNode{N_UNIQUECOUNT, nil, nil, nil, 0, nd_Prefix, nil},
		T_ISNOTNULL:   &ASTNode{N_ISNOTNULL, nil, nil, nil, 0, nd_Prefix, nil},
		T_ASCENDING:   &ASTNode{N_ASCENDING, nil, nil, nil, 0, nd_Prefix, nil},
		T_DESCENDING:  &ASTNode{N_DESCENDING, nil, nil, nil, 0, nd_Prefix, nil},

		T_TRAVERSE: &ASTNode{N_TRAVERSE, nil, nil, nil, 0, nd_Traverse, nil},
		T_PRIMARY:  &ASTNode{N_PRIMARY, nil, nil, nil, 0, nd_Prefix, nil},
		T_SHOW:     &ASTNode{N_SHOW, nil, nil, nil, 0, nd_Show, nil},
		T_SHOWTERM: &ASTNode{N_SHOWTERM, nil, nil, nil, 0, nd_Show, nil},
		T_WITH:     &ASTNode{N_WITH, nil, nil, nil, 0, nd_With, nil},
		T_LIST:     &ASTNode{N_LIST, nil, nil, nil, 0, nil, nil},

		// Boolean operations

		T_NOT: &ASTNode{N_NOT, nil, nil, nil, 20, nd_Prefix, nil},
		T_OR:  &ASTNode{N_OR, nil, nil, nil, 30, nil, ld_Infix},
		T_AND: &ASTNode{N_AND, nil, nil, nil, 40, nil, ld_Infix},

		T_GEQ: &ASTNode{N_GEQ, nil, nil, nil, 60, nil, ld_Infix},
		T_LEQ: &ASTNode{N_LEQ, nil, nil, nil, 60, nil, ld_Infix},
		T_NEQ: &ASTNode{N_NEQ, nil, nil, nil, 60, nil, ld_Infix},
		T_EQ:  &ASTNode{N_EQ, nil, nil, nil, 60, nil, ld_Infix},
		T_GT:  &ASTNode{N_GT, nil, nil, nil, 60, nil, ld_Infix},
		T_LT:  &ASTNode{N_LT, nil, nil, nil, 60, nil, ld_Infix},

		T_LIKE:        &ASTNode{N_LIKE, nil, nil, nil, 60, nil, ld_Infix},
		T_IN:          &ASTNode{N_IN, nil, nil, nil, 60, nil, ld_Infix},
		T_CONTAINS:    &ASTNode{N_CONTAINS, nil, nil, nil, 60, nil, ld_Infix},
		T_BEGINSWITH:  &ASTNode{N_BEGINSWITH, nil, nil, nil, 60, nil, ld_Infix},
		T_ENDSWITH:    &ASTNode{N_ENDSWITH, nil, nil, nil, 60, nil, ld_Infix},
		T_CONTAINSNOT: &ASTNode{N_CONTAINSNOT, nil, nil, nil, 60, nil, ld_Infix},
		T_NOTIN:       &ASTNode{N_NOTIN, nil, nil, nil, 60, nil, ld_Infix},

		// Simple arithmetic expressions

		T_PLUS:   &ASTNode{N_PLUS, nil, nil, nil, 110, nd_Prefix, ld_Infix},
		T_MINUS:  &ASTNode{N_MINUS, nil, nil, nil, 110, nd_Prefix, ld_Infix},
		T_TIMES:  &ASTNode{N_TIMES, nil, nil, nil, 120, nil, ld_Infix},
		T_DIV:    &ASTNode{N_DIV, nil, nil, nil, 120, nil, ld_Infix},
		T_MODINT: &ASTNode{N_MODINT, nil, nil, nil, 120, nil, ld_Infix},
		T_DIVINT: &ASTNode{N_DIVINT, nil, nil, nil, 120, nil, ld_Infix},

		// Brackets

		T_LPAREN: &ASTNode{N_LPAREN, nil, nil, nil, 150, nd_Inner, nil},
		T_RPAREN: &ASTNode{N_RPAREN, nil, nil, nil, 0, nil, nil},
		T_LBRACK: &ASTNode{N_LBRACK, nil, nil, nil, 150, nd_List, nil},
		T_RBRACK: &ASTNode{N_RBRACK, nil, nil, nil, 0, nil, nil},
	}
}

// Parser
// ======

/*
Parser data structure
*/
type parser struct {
	name   string          // Name to identify the input
	node   *ASTNode        // Current ast node
	tokens chan LexToken   // Channel which contains lex tokens
	rp     RuntimeProvider // Runtime provider which creates runtime components
}

/*
Parse parses a given input string and returns an AST.
*/
func Parse(name string, input string) (*ASTNode, error) {
	return ParseWithRuntime(name, input, nil)
}

/*
ParseWithRuntime parses a given input string and returns an AST decorated with
runtime components.
*/
func ParseWithRuntime(name string, input string, rp RuntimeProvider) (*ASTNode, error) {
	p := &parser{name, nil, Lex(name, input), rp}

	if node, err := p.next(); err != nil {
		return nil, err
	} else {
		p.node = node
	}

	return p.run(0)
}

/*
run models the main parser function.
*/
func (p *parser) run(right_binding int) (*ASTNode, error) {
	var err error

	n := p.node

	p.node, err = p.next()
	if err != nil {
		return nil, err
	}

	// Start with the null denotation of this statement / expression

	if n.nullDenotation == nil {
		return nil, p.newParserError(ErrImpossibleNullDenotation,
			n.Token.String(), *n.Token)
	}

	left, err := n.nullDenotation(p, n)
	if err != nil {
		return nil, err
	}

	// Collect left denotations as long as the left binding power is greater
	// than the initial right one

	for right_binding < p.node.binding {
		var nleft *ASTNode

		n = p.node

		p.node, err = p.next()

		if err != nil {
			return nil, err
		}

		if n.leftDenotation == nil {
			return nil, p.newParserError(ErrImpossibleLeftDenotation,
				n.Token.String(), *n.Token)
		}

		// Get the next left denotation

		nleft, err = n.leftDenotation(p, n, left)

		left = nleft

		if err != nil {
			return nil, err
		}
	}

	return left, nil
}

/*
next retrieves the next lexer token.
*/
func (p *parser) next() (*ASTNode, error) {

	token, more := <-p.tokens

	if !more {

		// Unexpected end of input - the associated token is an empty error token

		return nil, p.newParserError(ErrUnexpectedEnd, "", token)

	} else if token.Id == T_Error {

		// There was a lexer error wrap it in a parser error

		return nil, p.newParserError(ErrLexicalError, token.Val, token)

	} else if node, ok := astNodeMap[token.Id]; ok {

		return node.instance(p, &token), nil
	}

	return nil, p.newParserError(ErrUnknownToken, fmt.Sprintf("id:%v (%v)", token.Id, token), token)
}

// Standard null denotation functions
// ==================================

/*
nd_Term is used for terminals.
*/
func nd_Term(p *parser, self *ASTNode) (*ASTNode, error) {
	return self, nil
}

/*
nd_Inner returns the inner expression of an enclosed block and discard the
block token. This method is used for brackets.
*/
func nd_Inner(p *parser, self *ASTNode) (*ASTNode, error) {

	// Get the inner expression

	exp, err := p.run(0)
	if err != nil {
		return nil, err
	}

	// We return here the inner expression - discarding the bracket tokens

	return exp, skipToken(p, T_RPAREN)
}

/*
nd_Prefix is used for prefix operators.
*/
func nd_Prefix(p *parser, self *ASTNode) (*ASTNode, error) {

	// Make sure a prefix will only prefix the next item

	val, err := p.run(self.binding + 20)
	if err != nil {
		return nil, err
	}

	self.Children = append(self.Children, val)

	return self, nil
}

// Null denotation functions for specific expressions
// ==================================================

/*
nd_Get is used to parse lookup expressions.
*/
func nd_Get(p *parser, self *ASTNode) (*ASTNode, error) {

	// Must specify a node kind

	if err := acceptChild(p, self, T_NODEKIND); err != nil {
		return nil, err
	}

	// Parse the rest and add it as children

	for p.node.Token.Id != T_EOF {
		exp, err := p.run(0)
		if err != nil {
			return nil, err
		}

		self.Children = append(self.Children, exp)
	}

	return self, nil
}

/*
nd_Lookup is used to parse lookup expressions.
*/
func nd_Lookup(p *parser, self *ASTNode) (*ASTNode, error) {

	// Must specify a node kind

	if err := acceptChild(p, self, T_NODEKIND); err != nil {
		return nil, err
	}

	// Must have at least on node key

	if err := acceptChild(p, self, T_VALUE); err != nil {
		return nil, err
	}

	// Read all commas and accept further values as additional node keys

	for skipToken(p, T_COMMA) == nil {
		if err := acceptChild(p, self, T_VALUE); err != nil {
			return nil, err
		}
	}

	// Parse the rest and add it as children

	for p.node.Token.Id != T_EOF {
		exp, err := p.run(0)
		if err != nil {
			return nil, err
		}

		self.Children = append(self.Children, exp)
	}

	return self, nil
}

/*
nd_From is used to parse from group ... expressions.
*/
func nd_From(p *parser, self *ASTNode) (*ASTNode, error) {

	// Must be followed by a group keyword

	if err := acceptChild(p, self, T_GROUP); err != nil {
		return nil, err
	}

	// Must have a group name

	return self, acceptChild(p, self.Children[0], T_VALUE)
}

/*
nd_Traverse is used to parse traverse expressions.
*/
func nd_Traverse(p *parser, self *ASTNode) (*ASTNode, error) {

	// Must be followed by traversal spec

	if err := acceptChild(p, self, T_VALUE); err != nil {
		return nil, err
	}

	// Parse the rest and add it as children - must end with "end" if
	// further clauses are given

	for p.node.Token.Id != T_EOF && p.node.Token.Id != T_END {
		exp, err := p.run(0)
		if err != nil {
			return nil, err
		}

		self.Children = append(self.Children, exp)
	}

	if p.node.Token.Id == T_END {
		skipToken(p, T_END)
	}

	return self, nil
}

/*
nd_Func is used to parse functions.
*/
func nd_Func(p *parser, self *ASTNode) (*ASTNode, error) {

	// Must specify a name

	if err := acceptChild(p, self, T_VALUE); err != nil {
		return nil, err
	}

	// Must have an opening bracket

	if err := skipToken(p, T_LPAREN); err != nil {
		return nil, err
	}

	// Read in the first attribute

	if p.node.Token.Id == T_VALUE {

		// Next call cannot fail since we just checked for it. Value is optional.

		acceptChild(p, self, T_VALUE)

		// Read all commas and accept further values as parameters until the end

		for skipToken(p, T_COMMA) == nil {
			if err := acceptChild(p, self, T_VALUE); err != nil {
				return nil, err
			}
		}
	}

	// Must have a closing bracket

	return self, skipToken(p, T_RPAREN)
}

/*
nd_Show is used to parse a show clauses.
*/
func nd_Show(p *parser, self *ASTNode) (*ASTNode, error) {

	acceptShowTerm := func() error {
		st := astNodeMap[T_SHOWTERM].instance(p, p.node.Token)

		if p.node.Token.Id == T_AT {

			// Parse a function

			exp, err := p.run(0)
			if err != nil {
				return err
			}

			st.Children = append(st.Children, exp)

		} else {

			// Skip the value token from which we just created an AST node

			skipToken(p, T_VALUE)
		}

		// Parse an "as" definition if given

		if p.node.Token.Id == T_AS {

			current := p.node
			acceptChild(p, st, T_AS)

			if err := acceptChild(p, current, T_VALUE); err != nil {
				return err
			}
		}

		// Parse a "format" definition if given

		if p.node.Token.Id == T_FORMAT {

			current := p.node
			acceptChild(p, st, T_FORMAT)

			if err := acceptChild(p, current, T_VALUE); err != nil {
				return err
			}
		}

		self.Children = append(self.Children, st)

		return nil
	}

	// Read in the first node attribute

	if p.node.Token.Id == T_VALUE || p.node.Token.Id == T_AT {
		if err := acceptShowTerm(); err != nil {
			return nil, err
		}

		// Read further show entries

		for skipToken(p, T_COMMA) == nil {
			if err := acceptShowTerm(); err != nil {
				return nil, err
			}
		}
	}

	return self, nil
}

/*
nd_With is used to parse a with clauses.
*/
func nd_With(p *parser, self *ASTNode) (*ASTNode, error) {

	// Parse the rest and add it as children

	for p.node.Token.Id != T_EOF {
		exp, err := p.run(0)
		if err != nil {
			return nil, err
		}

		self.Children = append(self.Children, exp)

		if p.node.Token.Id == T_COMMA {
			skipToken(p, T_COMMA)
		}
	}

	return self, nil
}

/*
nd_WithFunc is used to parse directives in with clauses.
*/
func nd_WithFunc(p *parser, self *ASTNode) (*ASTNode, error) {

	// Must have an opening bracket

	if err := skipToken(p, T_LPAREN); err != nil {
		return nil, err
	}

	for p.node.Token.Id != T_RPAREN {

		// Parse all the expressions inside the directives

		exp, err := p.run(0)
		if err != nil {
			return nil, err
		}

		self.Children = append(self.Children, exp)

		if p.node.Token.Id == T_COMMA {
			skipToken(p, T_COMMA)
		}
	}

	// Must have a closing bracket

	return self, skipToken(p, T_RPAREN)
}

/*
nd_List is used to collect elements of a list.
*/
func nd_List(p *parser, self *ASTNode) (*ASTNode, error) {

	// Create a list token

	st := astNodeMap[T_LIST].instance(p, self.Token)

	// Get the inner expression

	for p.node.Token.Id != T_RBRACK {

		// Parse all the expressions inside the directives

		exp, err := p.run(0)
		if err != nil {
			return nil, err
		}

		st.Children = append(st.Children, exp)

		if p.node.Token.Id == T_COMMA {
			skipToken(p, T_COMMA)
		}
	}

	// Must have a closing bracket

	return st, skipToken(p, T_RBRACK)
}

// Standard left denotation functions
// ==================================

/*
ld_Infix is used for infix operators.
*/
func ld_Infix(p *parser, self *ASTNode, left *ASTNode) (*ASTNode, error) {

	right, err := p.run(self.binding)
	if err != nil {
		return nil, err
	}

	self.Children = append(self.Children, left)
	self.Children = append(self.Children, right)

	return self, nil
}

// Helper functions
// ================

/*
skipToken skips over a given token.
*/
func skipToken(p *parser, ids ...LexTokenId) error {
	var err error

	canSkip := func(id LexTokenId) bool {
		for _, i := range ids {
			if i == id {
				return true
			}
		}
		return false
	}

	if !canSkip(p.node.Token.Id) {
		if p.node.Token.Id == T_EOF {
			return p.newParserError(ErrUnexpectedEnd, "", *p.node.Token)
		}
		return p.newParserError(ErrUnexpectedToken, p.node.Token.Val, *p.node.Token)
	}

	// This should never return an error unless we skip over EOF or complex tokens
	// like values

	p.node, err = p.next()

	return err
}

/*
acceptChild accepts the current token as a child.
*/
func acceptChild(p *parser, self *ASTNode, id LexTokenId) error {
	var err error

	current := p.node

	p.node, err = p.next()
	if err != nil {
		return err
	}

	if current.Token.Id == id {
		self.Children = append(self.Children, current)
		return nil
	}

	return p.newParserError(ErrUnexpectedToken, current.Token.Val, *current.Token)
}
